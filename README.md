# AES-Example
An AES implementation in C++. This should NOT be used in any production systems. It was written as an exercise.


##Summary
The purpose of this project was to implement the AES encryption standard. The resulting program will be able to encrypt and decrypt messages of 16 characters with a 16 character key. The ciphertext will be generated by the following steps:
● generate round keys
● add initial round key
● for 9 rounds, do the following:
○ subBytes
○ shiftRows
○ mixColumns ○ add roundKey
● in the final round, do the following:
○ subBytes
○ shiftRows
○ add roundKey

To decrypt the message, these steps are reversed.
Compilation and Execution Instructions
To compile the program, simply run the following command:

g++ aes.cpp ­o aes

To run the program, execute the following in the directory of the compiled program: ./aes


##Explanation of Steps

subBytes: The subBytes step involves the use of a lookup table. For a given 2­digit hex number, this step takes the digits as column and row numbers, and returns a replacement number with an equal number of digits. This step is designed to provide confusion. That is, making the relationship between the ciphertext and plaintext as complex as possible. To reverse this transformation, a second table is used to reverse the lookups.

shiftRows: The shiftRows step involves a circular left rotation of each row in the current state matrix. Each row n is shifted left by n­1 places. To reverse this step, a right­circular rotation is applied in exactly the opposite manner.

mixColumns: The mixColumns step takes a state matrix and applies galois finite field multiplication. This operation alters the state matrix in a complex manner. To reverse this step, the constants used in the second matrix are changed.

add roundKey: The add roundKey step applies an XOR between the current ciphertext and the key that was generated for the particular round. The inverse of this step is exactly the same, since XOR is equivalent to addition and subtraction in galois field mathematics.

generate roundKeys: This step takes an initial key and produces 10 more keys that are used in each round for the add roundKey step.

##Implementation Notes

The program was written in c++. Though not as convenient as a higher level language, I chose to use c++ because I am very familiar with its data structures, and because I had better control over bit­level math.
This implementation was fairly straightforward, since the c++ standard library provides some useful data types. First, the valarray type was utilized. This allowed the use of ‘slices’ which made the matrix operations much easier to implement. Second, the complex operations for the finite field mathematics (used in the mixColumns step) were implemented using the bitset container. This allowed an implementation that was very similar to the mathematical definition of the operations on the inputs. The use of these two types of containers from the standard library made it easy to write concise, modular code.
